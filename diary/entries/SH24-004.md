<!--- metadata

title: H4 - Kääntöpaikka
date: 2024-11-14
slug:
id: ICI012AS3A-3001
week:
summary: Tehtävässä asennettiin Ghidra, analysoitiin ja muokattiin binäärejä, sekä ratkaistiin useita CrackMe-haasteita reverse engineering -menetelmin. Harjoiteltiin mm. salasanan etsimistä, ohjelman toiminnan ymmärtämistä ja binäärin patchausta.
tags: [ "ICI012AS3A-3001", "Application Hacking"]

--->

### Ympäristö

**OS:** Debian GNU/Linux 12 Bookworm

**Browser:** Firefox 128.3.1esr (64-bit)

**Hardware Model:** innotek GmbH VirtualBox

**Memory:** 5.7 GiB

**Processor:** AMD Ryzen 9 3900X - 6 cores used

**Disk:** 21.5 GB

**Network:** NAT

---

## x) Katso ja tiivistä. Tiivistämiseen riittää muutama ranskalainen viiva. Hammond 2022: Ghidra for Reverse Engineering (PicoCTF 2022 42. 'bbbloat') (Video, noin 20 min)

- Video käsittelee joitakin perusmenetelmiä, ennen ghidran käyttöä, kuten `strings` ja `file`

- Hän ratkaisee videolla picoCTF haastetta, jonka se onnistuneesti ratkaisemaan.

- Videolla esitetään mielenkiintoisia lähestymistapoja. Asioita mihin kiinnittää huomiota ja joitakin menetelmiä mitä kannattaa aina testata, kun tehdään staattista analyysiä.

[Hammond, 2022](https://www.youtube.com/watch?v=oTD_ki86c9I)

---

## a) Asenna Ghidra

Ensiksi piti asentaa jre ja jdk. Ne toteutuivat komennoilla `sudo apt install default-jre` ja `sudo apt install default-jdk` tämän jälkeen latasin ja unzippasin ghidra .zip tiedoston jonka jälkeen sen pystyi vain ajamaan ja ghidra lähti pyörimään.

**Ghidra 11.1.2** on asennettu onnistuneesti.

[Hogan, Boucheron & Horcasitas, 2022](https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-on-debian-11)

---

## b) rever-C. Käänteismallinna packd-binääri C-kielelle Ghidralla. Etsi pääohjelma. Anna muuttujille kuvaavat nimet. Selitä ohjelman toiminta. Ratkaise tehtävä binääristä, ilman alkuperäistä lähdekoodia. [ezbin-challenges.zip](https://terokarvinen.com/loota/yctjx7/ezbin-challenges.zip)

Eli kun ghidra saatiin auki, ensimmäisenä luodaan projekti, minne sitten importataan haluttu tiedosto.

![alt text](/assets/004-01/Screenshot 2024-11-14 121618.png)

Tämän jälkeen päästään analysoimaan ohjelmaa. Ihan ekana `symbol tree` valikosta mä etsin funktio hakemiston, ja sieltä main funktioo.

Tämä avasikin `Decompile` osion, jossa näkyi haluttu main funktio `C` kielellä. Siitä sitten lähdettiin muuttamaan muuttujia järkevän nimisiksi. Ja tunnilta muistinkin vielä että ensimmäisen int muuttujan voisi muuttaa `input` muuttujaksi. Tämä muuttuja siis on käyttäjän syöte.

Sitten char muuttujan mä nimesin `password` nimiseksi, sillä se on se syötetty tulos mitä verrataan itse oikeaan salasanaan. Tämä tuntui minulle loogisimmalta.

Yksinkertaisuudessaan ohjelma ihan ensimmäiseksi tulostaa stringin `"Whats the password?"` tämän jälkeen käyttäjä syöttää salasanan, minkä jälkeen Input muuttujassa `strcmp()` funktiossa käyttäjän syöttämä salasana ja oikea salasanaa verrataan toisiinsa.

![alt text](/assets/004-01/Screenshot 2024-11-14 121456.png)

Tämän jälkeen if lause määrittää että mikäli tässä `input` muuttuja on sama kuin 0, tarkoittaa se että käyttäjä on syöttänyt oikean salasanan. `Strcmp()` funktio siis yhdistää nämä kaksi stringiä, ja mikäli niissä on eroavia merkkejä, se kasvattaa ulostuloa `+=1`. Eli oikean salasanan ulostulo on 0 ja väärän `0 < x`. Ja tämän logiikan mukaan tulostetaan jompi kumpi if lauseen vaihtoehdoista.

---

## c) Jos väärinpäin. Muokkaa passtr-ohjelman binääriä (ilman alkuperäistä lähdekoodia) niin, että se hyväksyy kaikki salasanat paitsi oikean. Osoita testein, että ohjelma toimii. [ezbin-challenges.zip](https://terokarvinen.com/loota/yctjx7/ezbin-challenges.zip)

Seuraavaksi vuorossa oli muokata passtr ohjelman binääriä niin että ohjelma muuttaisi periaatteessa if lauseen toisinpäin. Eli lähdin avaamaan `main` funktiota samalla tavalla kuin b) tehtävässä. Sen jälkeen `Decompile` ikkunassa mä klikkasin if muuttujaa, joka hyppäsi haluttuun kohtaan `listening` näkymässä.

Päättelemällä ymmärsin että **JNZ** on ohje mitä assemblyn puolella pitää muuttaa, mutta en tiennyt, miten sen teen.

Googlailin siis ihan vain `"assembly JNZ"`, mistä heti sainkin vastauksen, mitä tämä ohje tekee. Eli tarkoittaa siis `Jump-Not-Zero` ja siinä samassa luki tän vastakohta, eli `JZ` mikä on `Jump-Zero`.

Maalaisjärjellä siis päättelin, että tässä haluttiin kääntää kyseinen if lauseke väärinpäin, niin menin muuttamaan JNZ:n JZ:ksi.

![alt text](/assets/004-01/Screenshot 2024-11-14 130543.png)

Käytännössä tämä onnistui `Patch instruction` toiminnolla jossa haluttua kenttää pystyttiin heti muuttamaan. Sitten muutettu ohjelmisto pitikin exportata. Tunnilla Teron vinkkiä noudattamalla ohjelman muotona pidettiin `original file`.

![alt text](/assets/004-01/Screenshot 2024-11-14 130823.png)

Tässä ohjelmalle piti vielä antaa ajo oikeudet, jonka jälkeen testaamalla selvisi, että muutos oli onnistunut ja kaikki toimi halutulla tavalla.

![alt text](/assets/004-01/Screenshot 2024-11-14 130849.png)

![alt text](/assets/004-01/Screenshot 2024-11-14 130940.png)

[Quora, 17.8.2024](https://www.quora.com/What-is-the-difference-between-the-JZ-and-JNZ-instructions-in-assembly-language)

---

## d) Nora CrackMe: Käännä binääreiksi Tindall 2023: [NoraCodes / crackmes](https://github.com/NoraCodes/crackmes). Lue README.md: älä katso lähdekoodeja, ellet tarvitse niitä apupyöriksi. Näissä tehtävissä binäärejä käänteismallinnetaan. Binäärejä ei muokata, koska muutenhan jokaisen tehtävän ratkaisu olisi vaihtaa palautusarvoksi "return 0"

Tässä tehtävässä latasin githubista zip tiedoston, missä oli kaikki tarvittavat tehtävät kun tiedoston unzippasi. Lähdin liikkeelle lukemalla ohjeiden ohjeistamana `README.md` tiedoston jossa selvisi miten tiedostoja ajetaan ja ratkaistaan.

Eli ensiksi lähdekoodit piti kääntää binääriksi `make crackme01` komennolla niin saatiin käännettyy source binääriksi. Ja sama toimii jokaisen tiedoston kohdalla muuttamalla vain tiedostonimeä.

[NoraCodes, 2024](https://github.com/NoraCodes/crackmes)

---

## e) Nora crackme01. Ratkaise binääri

Binääriä lähdin aluksi ratkaisemaan katsomalla `file` komennolla tiedoston rakennetta, siitä en saanut mitään sen enempää irti. Sitten kokeilin käyttää `strings` komentoa, mikä palauttikin jo heti halutun salasanan.

![alt text](/assets/004-01/Screenshot 2024-11-14 151033.png)

Tätä en kuitenkaan huomannut ensimmäisellä kerralla, kun ajoin ohjelman vaan työnstin binäärin ghidraan, josta alunperin sain vastauksen tietää.

![alt text](/assets/004-01/Screenshot 2024-11-14 151056.png)

Eli täysin vahingossa stringsin avulla selvisi salasana myös, vaikka ghidran kautta sain sen ensin tietää. Ja tosiaan salasana siis löytyy input muuttujan `strncmp()` funktion sisältä.

Sitten oli vuorossa `crackme01e`. Lähdin täysin samalla ideologialla liikkeelle eli stringsiä käyttämällä. Ja siellä näkyi jo oletettava salasana heti. Se näytti kuitenkin vähän hassulta, nii avasin binäärin myös ghidrassa, ihan vaan varmistaakseni että kyse on salasanasta. Ja ghidrassa asia varmistui, eli oikea asia oli kyseessä.

![alt text](/assets/004-01/Screenshot 2024-11-14 154552.png)

Sitten lähdin kokeilemaan salasanaa, mutta se ei onnistunut. Bash oli ihan sekasin eikä osannut tulkita `"!"` merkkiä. Kokeilin siis montaa eri asiaa, vaihtaa merkin hexa muotoon ja käyttää tupla hipsukoita mutta mikään ei toiminut, kunnes tajusin myös kokeilla yksittäisiä hipsukoita.

Olen aina tottunut käyttämään tupla hipsukoita, niin en tullut heti ajatelleeksi, että kyse voisi olla tästä, mutta onneksi oon törmännyt eri yhteyksissä siihen että välillä yksittäiset ja tupla hipsukat eivät tarkoita samaa.

![alt text](/assets/004-01/Screenshot 2024-11-14 154741.png)

Ja sieltä vastaus löytyikin. Hyvä harjoitus sinänsä, koska tämä on tulevaisuutta varten hyvä toimintatapa ottaa huomioon erikoismerkkien kanssa.

---

## f) Nora crackme02. Nimeä pääohjelman muuttujat käänteismallinnetusta binääristä ja selitä ohjelman toiminta. Ratkaise binääri

crackme02 olikin vähän isompi aivopähkinä. Eli kuten aikaisemmatkin tehtävät niin lähdin stringsillä, mikä paljasti salasanaksi `"password1"` mutta se ei kuitenkaan toiminut ja antoi väärää vastausta. Avasin binäärin sitten ghidrassa ja rupesin tuijottamaan `Decompiler` näkymää muutamien tuntien ajan. Yritin ymmärtää, miten ohjelma toimii.

Lähdin myös nimeämään muutujat kuvassa oleviin muotoihin, en tiedä onko ne oikein, mutta itselle ne tuntui loogiselta.

![alt text](/assets/004-01/Screenshot 2024-11-14 171634.png)

Heti alusta asti tajusin että alkuperäistä salasanaa muutetaan XOR tehtävistä tutuksi tulleen funktion tavoin. Toki tämä oli huomattavasti enemmän spagettia mulle, ja piti aika paljon käyttää päättelykykyä, että miten ohjelma voisi toimia. Ensimmäinen hypoteesi on että viimeistä integeriä muutetaan, mutta se osoittautui vain osittain oikeaksi.

Olin pitkään jumissa, kunnes päätin alkaa lukemaan tehtävien tekijän luomaa tutoriaalia (yritin välttää kuitenkin mahdollisimman paljon vastusten lukemista, ja napata vain vinkkejä) ja aika nopeasti heräsi ajatus, että ehkä ei vaan yhtä kirjainta yritetä muuttaa, vaan kaikkia kirjaimia muutetaan, esim. caesar cipher tyylisesti. Tästä ajatuksesta kun sain kiinni niin tehtävä ratkesi melko nopeasti tämän jälkeen.

[Tindall 2017](https://nora.codes/tutorial/an-intro-to-x86_64-reverse-engineering/)

Helpottaakseni tämän hahmottamista käytetään oikeita arvoja:

- **Comparison:** `'p'`

- **controlNumber:** `1`

Eli ohjelma vertaa linjalla 16 olevassa if lauseessa ASCII taulukossa olevan `'p'` arvoa `-1` arvoon eli `'o'` arvoon. Ja koska vertauksessa käytetään tätä `'p'` arvoa, niin tästä syystä vastaukseksi käy moni eri vaihtoehto kuten vaikka `o`, `o'r`, `o'rr` yms. eli ohjelma on hieman ongelmallinen. Oikea käännös tästä on kuitenkin `o\'ssword0`.

![alt text](/assets/004-01/Screenshot 2024-11-14 181451.png)

Ja myös tyhjä syöte toimii vastaukseksi, koska rivillä 15 oleva if lause skippaa kaikki tsekkaukset, koska syöte on tyhjä ja palauttaa heti `"\0"` arvon, mikä siirtyy suoraan riville 23 ja palauttaa oikean vastauksen. ASCII salasanan siirrokseen mä käytin [[https://www.dcode.fr/ascii-shift-cipher]] työkalua.

---

## g) Vapaaehtoinen: Ja sen yli. Crackme01 on useampia ratkaisuja. Montako löydät? Miksi?

En tiedä havaanko tässä tätä, mutta yksi tapa minkä löysin on että, kunhan ollaan käytetty `password1` niin sen jälkeen voi syöttää mitä tahansa merkkejä kuinka paljon vain. Eli se hyväksyy kaikki merkit oikeina `password1` osan jälkeen. Tämän osan eteen ei mitään pystynyt syöttämään kuitenkaan, eli `password1` pitää tulla ensimmäisenä.

---

## h) Vapaaehtoinen: Pyytämättäkin. Crackme02 on kaksi ratkaisua. Löydätkö molemmat?

Eli yksi tapa saada syöte on decoodaamalla binääri ja käyttämällä ghidraa esimerkiksi. Toinen tapa on syöttämällä ohjelmalle vain tyhjä syöte, jolloin ohjelma palauttaa oikean vastauksen. Käytin molempia vastauksia i) kohdassa ja siinä molemmat toimivat.

---

## i) Vapaaehtoinen, hieman haastavampi: A ray. Nora crackme02e. Ratkaise binääri

Samoilla toimenpiteillä kun aikaisemmissa tehtävissä sain stringsistä tietää salasanan mikä ei tietenkään toiminut. Näin siis ghidra auki ja analyysiä. Koodi oli melkein identtinen aikaisempaan tehtävään, lukuun ottamatta niin sieltä oli helppo tunnistaa avainarvo mikä oli `'y'` ja muunnos tällä kertaa on `-2`.

![alt text](/assets/004-01/Screenshot 2024-11-14 191621.png)

Näillä tiedoilla lähdin kokeilemaan aikaisempia menetelmiä ja tyhjällä syötteellä löytyy oikea vastaus, sekä `"w"` syötteellä, mikä on siis `'y'` avaimesta `-2` ASCII taulukossa.

![alt text](/assets/004-01/Screenshot 2024-11-14 185959.png)

En kuitenkaan meinannut millään löytää kokonaan oikeaa vastausta kunnes tajusin tätä vastausta kirjoittaessa että en tehnyt muutosta koko salasanalle, koska binäärikäännöksessä `'y'` puuttui muun salasanan edestä. Oikean vastauksen sai kuitenkin, kun muutti `yuvmnpoi` sanan `-2` käännöksellä ASCII taulukossa.

![alt text](/assets/004-01/Screenshot 2024-11-14 192331.png)

Tämä tehtävä oli hauska, koska tämä oli tahallaan tehty hämääväksi, sillä ASCII käännöksestä sai monta erilaista `"w"` alkuista käännöstä ja myös, kun tässä vaiheessa alkoi jo olemaan aika hyvin ymmärrystä sekä osaamista niin tämä tuntui juuri sopivalta haasteelta.

---

### Lähteet

#### 1. Hogan, Boucheron & Horcasitas. 2022. How To Install Java with Apt on Debian 11. DigitalOcean. Luettavissa: [[https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-on-debian-11]] Luettu: 14.11.2024

#### 2. Quora. 17.8.2024. What is the difference between the JZ and JNZ instructions in assembly language. Quora. Luettavissa: [[https://www.quora.com/What-is-the-difference-between-the-JZ-and-JNZ-instructions-in-assembly-language]] Luettu: 14.11.2024

#### 3. Tero Karvinen. 2024. Ezbin Challenges. Tero Karvinen. Luettavissa: [[https://terokarvinen.com/loota/yctjx7/ezbin-challenges.zip]] Luettu: 14.11.2024

#### 4. NoraCodes. 2024. An Intro to x86_64 Reverse Engineering. NoraCodes. Luettavissa: [[https://nora.codes/tutorial/an-intro-to-x86_64-reverse-engineering/]] Luettu: 14.11.2024

#### 5. NoraCodes. 2024. Crackmes. NoraCodes. Luettavissa: [[https://github.com/NoraCodes/crackmes?tab=readme-ov-file]] Luettu: 14.11.2024

#### 6. Hammond, 2022. Ghidra for Reverse Engineering (PicoCTF 2022 #42 'bbbloat'). Youtube. Katsottavissa: [[https://www.youtube.com/watch?v=oTD_ki86c9I]] Katsottu: 14.11.2024

#### 7. Tindall 2017. An Intro to x86_64 Reverse Engineering. Luettavissa: [[https://nora.codes/tutorial/an-intro-to-x86_64-reverse-engineering/]] Luettu: 14.11.2024
